// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: expenses.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const createExpenses = `-- name: CreateExpenses :one
INSERT INTO expenses (
    name,
    amount,
    user_id,
    group_code
) VALUES (
$1, $2, $3 ,$4
) RETURNING id, name, amount, user_id, group_code, created_at, updated_at
`

type CreateExpensesParams struct {
	Name      string  `json:"name"`
	Amount    float64 `json:"amount"`
	UserID    int64   `json:"user_id"`
	GroupCode string  `json:"group_code"`
}

func (q *Queries) CreateExpenses(ctx context.Context, arg CreateExpensesParams) (Expense, error) {
	row := q.db.QueryRowContext(ctx, createExpenses,
		arg.Name,
		arg.Amount,
		arg.UserID,
		arg.GroupCode,
	)
	var i Expense
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Amount,
		&i.UserID,
		&i.GroupCode,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getExpense = `-- name: GetExpense :one
SELECT 
    e.name AS expense_name,
    e.amount AS expense_amount,
    u.username AS payer_username,
    g.name AS group_name,
    s.share_type,
    s.share_value,
    u2.username AS shared_with_username
FROM 
    expenses e
JOIN 
    users u ON e.user_id = u.id
JOIN 
    e_group g ON e.group_code = g.code
JOIN 
    share s ON e.id = s.expense_id
JOIN 
    users u2 ON s.user_id = u2.id
WHERE 
    e.id = $1
`

type GetExpenseRow struct {
	ExpenseName        string          `json:"expense_name"`
	ExpenseAmount      float64         `json:"expense_amount"`
	PayerUsername      string          `json:"payer_username"`
	GroupName          string          `json:"group_name"`
	ShareType          string          `json:"share_type"`
	ShareValue         sql.NullFloat64 `json:"share_value"`
	SharedWithUsername string          `json:"shared_with_username"`
}

func (q *Queries) GetExpense(ctx context.Context, id int64) (GetExpenseRow, error) {
	row := q.db.QueryRowContext(ctx, getExpense, id)
	var i GetExpenseRow
	err := row.Scan(
		&i.ExpenseName,
		&i.ExpenseAmount,
		&i.PayerUsername,
		&i.GroupName,
		&i.ShareType,
		&i.ShareValue,
		&i.SharedWithUsername,
	)
	return i, err
}

const listExpenses = `-- name: ListExpenses :many
SELECT 
    e.id AS expense_id,
    e.name AS expense_name,
    e.amount AS expense_amount,
    e.user_id AS payer_user_id,
    s.user_id AS sharing_user_id,
    s.share_type,
    s.share_value,
    e.created_at,
    e.updated_at
FROM 
    expenses AS e
LEFT JOIN 
    share AS s ON e.id = s.expense_id
`

type ListExpensesRow struct {
	ExpenseID     int64           `json:"expense_id"`
	ExpenseName   string          `json:"expense_name"`
	ExpenseAmount float64         `json:"expense_amount"`
	PayerUserID   int64           `json:"payer_user_id"`
	SharingUserID sql.NullInt64   `json:"sharing_user_id"`
	ShareType     sql.NullString  `json:"share_type"`
	ShareValue    sql.NullFloat64 `json:"share_value"`
	CreatedAt     time.Time       `json:"created_at"`
	UpdatedAt     time.Time       `json:"updated_at"`
}

func (q *Queries) ListExpenses(ctx context.Context) ([]ListExpensesRow, error) {
	rows, err := q.db.QueryContext(ctx, listExpenses)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListExpensesRow{}
	for rows.Next() {
		var i ListExpensesRow
		if err := rows.Scan(
			&i.ExpenseID,
			&i.ExpenseName,
			&i.ExpenseAmount,
			&i.PayerUserID,
			&i.SharingUserID,
			&i.ShareType,
			&i.ShareValue,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
